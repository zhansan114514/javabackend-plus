# 前端版块任务

## 前言

和前端交互的数据库表就是我们所涉及的所有表了，我把他们的定义写在下面：

ps : 提示一个地方，摄像头表的caId是他的主键，但是我实现的时候并没有把名字设为caId,因为使用gorm.Model，里面带有ID作为主键，这个ID就是caId

ps: 以防同学还是对unix时间不是很懂，在这里解释一下，希望你是做完了task1才看到这个解释（这样也更能加深印象😁）

unix时间戳是从UTC时间1970年1月1日起到现在的秒数，不考虑闰秒，一天有86400秒，它是和时区无关的。这是关键点。我们给一个时间，比如2023-11-23 5:09:10 这是一个很友好的时间显示，但是这种时间我们就要确定是什么时区，是在上海时区还是在美国什么的。而你仔细想想，难道上海时区的时间和其它时区就会不一样吗？地球出现过后，每个地方都是经过相同的时间，如果我们把经过的时间的秒数来记录，就没有时区的概念了吧，就像虽然我们现在的时间和美国时间不一样，但是都是在同一个时刻，都是地球从产生到现在经过了相同的秒数到达的时刻，所以这就是时间戳的关键，它完全与时区无关， 时区这样的描述是方便我们生活中更方便的使用时间，毕竟别人问你时间，不可能你回答一个：目前从公认的UTC时刻1970年1月1日到现在的秒数为xxxxxxx秒吧。但这个就是unix时间戳的定义。

### 1、用户表

| 字段名称      | 字段  类型 | 字段  默认值 | 是否允  许为空 | 是否  主键 | 示例                |
| ------------- | ---------- | ------------ | -------------- | ---------- | ------------------- |
| id            | int        |              | 否             | 是         | 1                   |
| name          | string     |              | 否             |            | “张三”              |
| passwd        | string     |              | 否             |            | “VF15V21GD52V1D2FV” |
| role          | int        |              | 否             |            | 0                   |
| release_time  | int64      |              | 是             |            | 1689120000          |
| deadline_time | int64      |              | 否             |            | 1846368000          |
| login_start   | int64      |              | 否             |            | 51360000000000      |
| login_end     | int64      |              | 否             |            | 72000000000000      |
| fail_times    | int        | 0            | 否             |            | 3                   |

**字段解释如下：**

- id:主键，int，用来标识用户，顺序递增；
- name:用户名，string，用户的昵称，也需要同其他用户不重复；
- passwd:密码，设置最多255位字符串，采用SHA256加密方式加密后存储于数据库内；
- role:用户角色，若为1，则为管理员角色，若为2，则为普通用户，用于区分不同角色；
- release_time:冻结期字段，用于限制用户在输入密码错误次数超过3次后，才更新该字段，若当前时间小于有效期字段，则视为超出使用时间范围，则该用户不可登录；**int64类型，因为是unix时间戳**
- deadline_time:有效期字段，用于限制用户的使用时长，若当前时间大于有效期字段，则视为超出使用时间范围，则该用户不可登录；int64类型，因为是unix时间戳
- login_start:开始登录时间，该字段用于限定该用户每日开始登录的时间，只有当前时间大于该值时，该用户才可登录；int64类型，仿照unix时间戳形式，大小时距离0点的时间长度，以纳秒为单位，从而得到一个时间戳，比如示例里面的51360000000000，换成时间就是"14:16"
- login_end:结束登录时间，该字段用于限定该用户每日结束登录的时间，只有当前时间小于该值时，该用户才可登录；int64类型，仿照unix时间戳形式，大小时距离0点的时间长度，以纳秒为单位，从而得到一个时间戳，比如示例里面的72000000000000，换成时间就是"20:00"
- fail_times:该用户连续登录失败次数，该次数超过3触发用户冻结选项。

### 2、摄像头表

| 字段名称    | 字段  类型 | 字段  默认值 | 是否允  许为空 | 是否  主键 | 示例              |
| ----------- | ---------- | ------------ | -------------- | ---------- | ----------------- |
| id          | int        |              | 否             | 是         | 1                 |
| name        | string     |              | 否             |            | “Camera_01”       |
| ip          | string     |              | 否             |            | “192.168.1.64”    |
| port        | string     |              | 否             |            | “554”             |
| channel     | int64      |              | 否             |            | 1                 |
| user        | string     |              | 否             |            | “admin”           |
| passwd      | string     |              | 否             |            | “admin123”        |
| area        | string     |              | 否             |            | “猛追湾”          |
| start_time  | int64      |              | 否             |            | 28800000000000    |
| end_time    | int64      |              | 否             |            | 79200000000000    |
| infer_class | []string   |              | 否             |            | [“fight”,“drunk”] |

- id(在数据库中）/ca_id:主键，用于标识摄像头序号，顺序递增；
- name:摄像头名字，用户期待系统显示出摄像头的名称；
- ip:摄像头网络ip，用于访问摄像头；
- port:摄像头网络port，用于访问摄像头；
- channel:该字段为访问摄像头中一个必不可少的字段，不同的channel意味着这台监控主机所显示的不同画面；
- user:该字段为登录该摄像头的用户名字段；
- passwd:该字段为登录该摄像头的密码字段；
- area:区域，限定该摄像头来自哪个辖区内；
- start_time:该摄像头开始检测时间；int64类型，仿照unix时间戳形式，大小时距离0点的时间长度，以纳秒为单位，从而得到一个时间戳，比如示例里面的28800000000000，换成时间就是"08:00"
- end_time:该摄像头结束检测时间；int64类型，仿照unix时间戳形式，大小时距离0点的时间长度，以纳秒为单位，从而得到一个时间戳，比如示例里面的79200000000000，换成时间就是"22:00"
- infer_class:该摄像头检测类别列表。

### 3、报警信息表

| 字段名称   | 字段  类型 | 字段  默认值 | 是否允  许为空 | 是否  主键 | 示例                                              |
| ---------- | ---------- | ------------ | -------------- | ---------- | ------------------------------------------------- |
| id         | int        |              | 否             | 是         | 1                                                 |
| ca_id      | int        |              | 否             |            | 2                                                 |
| alert_time | int64      |              | 否             |            | 1689120000                                        |
| type       | string     |              | 否             |            | “fight”                                           |
| path_video | string     |              | 可             |            | “/root/src/videoSource/20230705/1/fight/0959.avi” |
| path_photo | string     |              | 否             |            | “/root/src/photoSource/20230705/1/fight/0959.jpg” |

- id:主键，int，标识报警信息的唯一性，顺序递增；
- ca_id:摄像头id，用于标识报警信息来自于哪一个摄像头；
- alert_time:报警时间，标识报警事件发生的时间；**int64类型，因为是unix时间戳**
- type:报警类型，即标识不同的触发报警的事件类型；
- path_video:该字段存储的是报警视频在服务器中的存储路径。
- path_photo:该字段存储的是报警视频在服务器中的存储路径。

### **<u>这里就需要强调我们这个报警信息的处理过程了</u>**

后端机器学习部分检测到嫌疑犯，就会向服务器发送检测到嫌疑犯的图片，以及是哪个摄像头（ca_id）在什么时间(alert_time)检测到嫌疑犯是什么类型的犯罪（type），只要是ca_id alert_time type组合起来是不同的，就说明这是一条不同的报警信息，就不算做重复，需要按照alertType/alertTimeString-caIdString.jpg这样的格式存储到photoSource路径下面，而这个时候报警视频还没有传过来，因为后端还会等一会儿，所以这里会分成两个接口![image-20230802155650824](https://fastly.jsdelivr.net/gh/KMSorSMS/picGallery/img/202308021620539.png)对应着不同的环节，后面报警视频上传的时候，我们从apifox里面也能看到，警报信息和视频上传的请求格式都是form-data了，因为这样能直接上传二进制文件，然后我们要先检查报警视频对应的报警信息部分是否是已经存在的，因为必须要存在你这个视频才能传输上去，然后在再接收这个报警视频，并且更新数据库表的信息。

这个流程是很重要到，当然你写到这部分的题目的时候也会有注释来提醒你这一点。

### 4、检测框表(box)

| 字段名称   | 字段  类型 | 字段  默认值 | 是否允  许为空 | 是否  主键 | 示例       |
| ---------- | ---------- | ------------ | -------------- | ---------- | ---------- |
| id         | int        |              | 否             | 是         | 1          |
| ca_id      | int        |              | 否             |            | 2          |
| left_up    | string     |              | 否             |            | “0.2  0.2” |
| right_down | string     |              | 否             |            | “0.2  0.2” |

id:主键，int，用来标识检测区域框信息的唯一性；

ca_id:摄像头id，用于标识报警信息来自于哪一个摄像头；

left_up:每一条矩形框数据左上角的点“x y”所占整个图像（w，h）的比例；

right_down:每一条矩形框数据右下角的点“x y”所占整个图像（w，h）的比例。

**注意：**

可以看到同一个ca_id下可以有多条数据，只要他们的  left_up    right_down   ca_id  的组合不重合就可以了，因为用户完全可以在一个摄像头检测的区域多画一些检测框嘛

![image-20230802160544047](https://fastly.jsdelivr.net/gh/KMSorSMS/picGallery/img/202308021620540.png)

-------

## 任务

## task2 摄像头业务---cameraTransaction

任务中的接口都定义在CameraTransactionController中😊。

由于是task2我保留了我自己写的代码的大部分注释，你可以参照我的注释写，但是也可以有些地方有不同，是鼓励这样的。

而且task2里面大部分内容和登录版块很像，登录版块是在UserTransactionController。

### 2.1实现摄像头增加接口---AddCamera

前端是一个POST请求（请根据restful风格分析一下为什么是POST请求），下面是它的body体

```json
{
    "name": "test1",
    "ip": "6.229.214.80",
    "port": "3306",
    "user": "Rick",
    "passwd": "wubalubadubdub",
    "channel": 1,
    "area": "成华区",
    "startTime": "8:00",
    "endTime": "22:00",
    "inferClass": [
        "fight",
        "chat"
    ]
}
```

只需要返回状态信息即可，比如这是成功的信息

```json
{
    "code": 200,
    "data": {
        "message": "添加成功",
        "status": 0
    },
    "message": "添加成功"
}
```

这些内容在apifox上都有，所以后面的题目描述里面就不会再说了，并且你的调试也是需要apifox来模拟前端发送请求的，这也是为什么前置内容需要学清楚

### 2.2实现摄像头删除接口---DeleteCamera

参见apifox文档

### 2.3实现摄像头获得接口---GetCamera

参见apifox文档

### 2.4实现摄像头时间修改接口---UpdateCamera

参见apifox文档

## task3检测框业务

任务中的接口都定义在BoxTransactionController中😊

这里因为前面你已经熟悉了基本流程，那么我在这里做一点题型的改变，我们这个部分业务有三个接口分别对应为add、delete、get,我会给你delete也就是检测框删除的完整代码，但接下来你需要完成get和add部分的代码，其中add部分有注释，get部分没有注释

### 3.1实现检测框添加接口---AddBox

### 3.2实现检测框获取接口---GetBox

-------

## task6报警信息业务

你肯定想问为啥这里是task6，因为这部分内容中有个接口和前面相似度不高，就想让你先去后端版块把task4做了再来，`当然报警信息获取和报警信息删除两个接口是和前面类似的`，所以为了体现一点这是后面的题目，我们就去掉了在函数体里面的注释，只留下对函数本身功能的解释。**并且这里有一个bonus点**

后端部分的题目同样在README里面，地址是和这里平行的，我给一个链接[后端模块题目](.\src\README.md)

任务中的接口都定义在AlertTransactionController

为了节省你的时间，报警信息删除的接口已经写好了，而你要完成的就剩下报警信息获取接口，和报警资源(视频or图片)获取接口

### 6.1实现报警信息获取接口---GetAlert

这里就要仔细阅读报警信息筛选的条件喔，还要考虑为空的形式，鉴于这是最后一个业务板块，我不再提供注释，需要从0开始写哦。

这里面对于unix时间的理解十分重要！！！

### 6.2实现报警资源(视频or图片)获取接口---GetAlertSrc

同样的，我没有给注释，需要你自己来实现，这里要采取流的形式来传送文件喔🥰！

------

## Task7 在Linux环境下运行

这个task是让你在linux环境下运行这个程序，算是比较小的bonus了，但是注意，这个不需要你把代码写完，你甚至可以用题目代码，就是什么都没有做的代码，然后成功在linux的机器上运行，就算完成了任务。

linux的发行版推荐是centos7(因为不收费)或者Ubuntu，当然你想选择其他的也是可以的。

不过个人推荐先用centos7更能体验一下服务器环境（不装ui界面），当然ubuntu也是可以的，要是小白的话，先从ubuntu开始吧。

安装其他软件之前，换一个shell吧，用用zsh怎么样？----[别人写的安装zsh的博客](https://jsharkc.github.io/post/centos-install-oh-my-zsh/)

有可能你下载中途一直卡住，因为国内墙的原因，试试这个---[解决国内安装问题](https://blog.csdn.net/qimowei/article/details/119517167)，后面可以自己选择主题，选择一些补全插件🥰。

# bonus1

这里我们的bonus是在你前面已经完成的基础上的一点点小优化。仔细想想，报警信息获取实际上就是客户端获取到报警信息的唯一方式，但是这需要客户端不断的向你服务器询问：有没有报警信息呀？最近有没有呀?，这种，不是很好，我们希望是服务器主动向客户端说：我有报警信息，这边有嫌疑犯!

要解决这个问题，你需要先知道轮询和长连接两个概念。

接下来是一种长连接方式---websocket  [了解websocket机制](https://juejin.cn/post/7020964728386093093)

 并且为了让你的后端内容一发送过来给你这个服务端，就能马上的主动转发到客户端，这个其实实现不难，但是需要了解一些知识然后运用出来，并且也需要你对之前的代码比较了解。

# bonus2

这个bonus是将你之前写的报警视频与图片上传进行优化，实现报警视频/图片资源断点续传功能，也就是当用户因为网络故障原因导致内容传输中断，在下一次用户重新发起请求的时候不是重新发送全部内容，而是从上次中断开始发送。这个功能实现完全是自己写的，需要自己拓展功能，你可以自己在apifox里面改进原来的报警资源获取接口并进行测试。

另外，你可以进行考虑，在本地进行文件的存储的弊端，有什么其他的方式可以进行解决呢？请进行尝试。

# bonus3

请你想想该如何实现多个机器学习后端分配资源的管理，也就是要合理的将需要解析的摄像头任务分配给后端的多个机器学习服务器，当有新的后端服务器上线或者下线的时候做出动态的调整。由于这个功能实现方式特别多，你可以完全自由的设计后端交互模块的接口，在原有的接口上改进或者重新写一个新的接口都是可以的。资源的分配上只需要平均分配，注意要想办法怎么设计接口使得服务器能够知道后端上线或者下线，以及怎么去记录信息，而分配任务上只需要平均分配给他们摄像头信息就可以了。
